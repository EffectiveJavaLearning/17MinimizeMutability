import java.io.ObjectInputStream;
import java.math.BigInteger;

/**
 * 不可变类指其实例不能被修改的类。每个实例中包含的信息在其生命周期内都是不可变的。
 * Java类库中包含许多不可变类，包括{@link String}、装箱基本元素类、{@link java.math.BigInteger}、
 * {@link java.math.BigDecimal}等。
 * 不可变类比可变类更易于设计、实现和使用，而且它们不太容易出错，更具安全性。
 *
 * 要使类不可变，需要遵守下面5条规则。
 * 1.不要提供修改对象状态的方法(也称为mutators)
 *     2.保证类不可以被子类继承和扩展。这样可以阻止由于粗心或恶意子类模拟出改变父类状态的动作，
 *     令其状态看上去已经发生了改变，从而破坏父类的不可变性。为防止被子类继承，一般做法是把它设置成
 *     final型，但也有一个其他的替代方式，之后会提到。
 *     3.所有字段设置成final型。这么一弄系统就会自动帮你禁止对这些字段的修改，你的意图就很清楚了。
 *     此外，有必要保证新创建的实例使用不可变对象时，在缺少同步机制的多线程情况下不会出现差错，
 *     就像内存模型(memory model)中所述的那样。
 *     4.所有字段设置成private型。可以阻止客户端访问字段所引用的可变对象，或者对字段进行直接修改。
 *     虽然不可变类中有public final型的基本型变量或者不可变对象的引用，编译器不会报错，
 *     但不建议这样做。因为它这种形式会给以后的更新带来很大的麻烦(见item15和item16)。
 *     5.确保对任何可变对象的互斥访问。如果类中有指向可变对象的引用，那么要保证客户端不可能获取到它，
 *     并且永远不要为了让客户端使用而初始化它，也不要为它设置getter方法。在构造方法、访问方法或者
 *     readObject方法(见Item 88: Write readObject methods defensively)中，考虑使用保护性拷贝
 *     (defensive copy，见Item 50: Make defensive copies when needed)
 *
 * 之前很多例子都针对的是这种不可变对象，但现在我们来看一个复杂一点的例子{@link Complex},
 * 以便于说明函数式方法与过程式方法的区别。
 *
 * 不可变对象由于其不可变性，因此它们是线程安全的，无需同步，也不用担心并发会引发异常。
 * 因此，不可变对象可以被任意地共享，应当尽可能地使用已创建的实例。一种常见的应用场景是，
 * 为常用的值提供公共静态最终常量，例如{@link Complex#ZERO}, {@link Complex#ONE},
 * {@link Complex#I}
 *
 * 这种方法可以被进一步扩展：不可变类通过静态工厂缓存常用实例，以避免重复创建。
 * ({@link java.math.BigInteger}和所有基本类型的装箱类差不多都是这么处理的)
 * 这样用共享代替新建的方式，能够有效减少内存和GC的开销。因此我们设计新的类时，
 * 可以选择用静态工厂代替公有的构造方法，以便于在不影响客户端工作的前提下，
 * 保留稍后添加缓存机制的灵活性。
 *
 * 不可变对象任意共享的另一个优势是无需费劲处理防御性副本(defence copies)的问题。
 * 既然副本与实例本身等价，而不可变实例又不会发生状态改变，那么很容易理解为什么没必要进行拷贝了。
 * 不过在Java刚出现时，{@link String}还真的有拷贝型构造方法(public String(String original)),
 * 但这个方法应当尽量少用。
 *
 * 共享时，不仅可以共享该实例，而且还可以共享其内部信息。比如，{@link java.math.BigInteger}
 * 的内部使用了符号数值表示法，用一个int型的值表示符号，然后用一个int型数组表示其巨大的数值。
 * 其中，它的{@link BigInteger#negate()}相反数方法中，new出一个符号与本身相反，数值与本身相同的，
 * 新的BigInteger类出来并返回，但此时无需对数组调用其clone()方法，就算它是可变的也一样，
 * 直接使用指向原实例中内部数组的引用就好。
 *
 * 不可变对象为其他对象提供了大量可变与不可变的构件。如果已知某复杂对象的内部组件不会改变，
 * 那么维护其不变性约束就会容易得多。不过也有特例：当不可变对象构成了大量的map key 和
 * set element时，一旦不可变对象进入到map或者set中，不会破坏映射或集合的不变性约束，
 * 因为它们的值不会发生变化。
 *
 * 不可变对象还顺便提供了故障的原子性，因为状态不变，所以不可能出现状态不一致问题。
 *
 * 不可变对象的主要缺点是其需要为不同的值创建相互独立的实例，而有时候创建的代价或许会非常高，
 * 比如需要修改一个上亿位BigInteger实例的最后几位，函数式方法中我们不得不创建新实例
 * {@link BigInteger#flipBit(int)}，这个方法耗时与实例规模成正比。与之类似的
 * {@link java.util.BitSet}也可以表示任意长度的位序列，但这个是可变对象。因此BitSet更改某一位时，
 * 就可以直接在数组中进行修改而不需要重新创建{@link java.util.BitSet#flip(int)}。
 *
 * 当我们执行多步操作时，如果每一步都生成一个新的对象，而最终结果却仅仅使用最后一步生成的结果，
 * 中间结果一律抛弃，那么性能就会严重受损，一般针对这种问题有两种解决方式：
 *      1.将常用的部分或全部步骤作为原语提供，这样就可以减少中间对象的生成
 *      2.使用可变类型的配套类，如放到{@link BigInteger}内部的
 *      {@link java.math.BigInteger.UnsafeHolder}。这些配套类虽然是可变的，
 *      但线程安全等问题都已经帮程序员处理掉了，直接用就ok.
 *      再如{@link String}的配套类{@link StringBuilder}&{@link StringBuffer}
 *      进行多次字符串连接(append())时速度会明显高于String的加号(+)；
 *      在能够预测要对不可变对象进行哪些操作时，{@link java.math.BigInteger.UnsafeHolder}
 *      这种package-private型配套类可以大大提高效率；否则，最好像{@link StringBuffer}一样，
 *      通过public型的可变配套类解决。
 *
 * 下面是几种关于不可变类的设计方案。前面提过，为了确保不可变性，类不可以允许自己被子类继承。
 * 除了对类添加final关键字以外，还有一种更加灵活的方式实现这一点：
 * 将该类所有的构造方法改为private型或package-private型，然后添加public型的静态工厂方法替代构造方法。
 * 比如{@link Complex2}，由于客户端位于该包外部，这种类实际上等价于final型：不能直接访问re和im，
 * 又不能直接继承来自其他package且缺少public型或者protected型构造方法的类。
 *
 * 不过，在{@link java.math.BigInteger}和{@link java.math.BigDecimal}被设计出来的时候，
 * 由于认知局限性，"不可变类必须设置为final型"这一点没有被广泛地理解，因而它们的所有方法都有可能会被覆盖，
 * 而为了保持向后兼容，这个问题又一直没办法修复。假如自己编写的类依赖于{@link java.math.BigInteger}和
 * {@link java.math.BigDecimal}的参数不可变性，那么十分有必要检测这些参数是不是“真的”不可变类，
 * 而不是这两个类乱七八糟无法信任的子类。万一可变，就有必要进行防御性拷贝。
 *
 * 最初的5条通用规约表示，任何方法都不能修改全成员变量为final型的对象。实际上，
 * 这些规则要比实际需求稍稍严格一些，如果对性能有要求，则可以适当地放松。
 * 按照规约应该是，任何方法都不能对不可变对象的状态产生外部可见的改变；但开发过程中，
 * 有些不可变类中会有一个或多个可变字段，用于缓存高开销操作的结果，从而在应对同样请求时可以迅速响应。
 * 敢这么干的理由也是因为这个对象是不可变的，因此重复计算会得到同样结果。
 *
 * 例如，PhoneNumber的hashCode方法(item11中)第一次调用时计算哈希值，并缓存它以供下次调用使用。
 * 这个技术，在Sting的lazy initialization中也出现过。
 *
 * 关于序列化需要注意一下。如果想自己设计的不可变类implements Serializable,而它又包含了可变字段，
 * 那么就必须提供显式的readObject()或readResolve()方法，或者使用
 * {@link java.io.ObjectOutputStream#writeUnshared(Object)}和{@link ObjectInputStream#readUnshared()}
 * 方法。就算默认的序列化表单(form)没毛病也得这么干。否则，坏蛋们可能会创建你类中的可变对象实例，
 * 破坏你的程序。这一点在item 88中也会提到。
 *
 * 总之，不要急着为所有getter方法编写对应的setter，除非有充分的理由这么做；实例也应该是默认不可变的，
 * 只有当理由充分时才能将其改成可变。不可变类有很多优势，唯一缺陷是某些情况下会存在性能问题。
 * 所有应当将像{@link Complex}这样的小型的值类实例(value object)设置为不可变。
 * (虽然一些Java类库中的类也犯了这种错误，比如{@link java.util.Date},{@link java.awt.Point})
 *
 * 对于大型的值类实例，比如BigInteger这种，在设置为不可变类的同时应当考虑为它编写一个public型
 * 可变的配套类以满足性能需求。
 *
 * 如果一个类无法被设置成不可变类型，那么考虑如何尽量限制其可改变性，比如减少其可能存在的状态，
 * 以减少出错的可能性。比如{@link java.util.concurrent.CountDownLatch},
 * 其状态空间有意识地被设置得尽量小。创建，然后使用一次，它的任务就完成了，不可以再被重用。
 *
 * 与item15限制字段的可访问性相结合，应当更加倾向于把所有字段设置成private final型。
 *
 * 所有不可变字段应当在构造方法中全部赋值并建立正确的约束关系，除非必要，否则尽量少提供除了构造方法、
 * 静态工厂方法之外的public型初始化方法，也不要想着通过“重初始化”让对象能够复用，
 * 这些方式为了一丢丢效率往往会把代码搞得很复杂。
 *
 * 最后，关于Complex类，它仅仅用于演示本条item，并不胜任产品级的需求，其复数乘除会进行不正确的舍入，
 * 对NaN和无穷大也没有提供语义支持。
 *
 *
 * @author LightDance
 */

public class MinimizeMutability {
}
